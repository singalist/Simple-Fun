#include <graphics.h>
#include <conio.h>
#include <math.h>
#include "MyTimer.h"				// 一个保证精确延时的类。下载于 easyx 官网
#pragma comment(lib, "Winmm.lib")	// 给游戏添加音乐要用到它

#define G		9.8					// 重力加速度
#define SCREENX	640				    // 屏幕大小
#define SCREENY	480
/*#define X		64					// 主角起始位置
#define Y		192
#define W		32					// 主角的宽和高
#define H		32*/
#define STEP	4					// 主角走一步相距的像素个数
#define HIGH	(2*eye.w+1)		// 主角跳跃的最大高度

#define	CMD_LEFT	1				// 方向键
#define	CMD_RIGHT	2
#define	CMD_UP		4
#define CMD_DOWN	8
#define CMD_SHOOT	16
#define CMD_ESC		32

struct EYE
{
	int id;
	int x;			// 横坐标
	int y;			// 纵坐标
	int w;			// 图片宽度
	int h;			// 图片高度
	int turn;		// 眼睛的运动方向
	int jump;		// 眼睛是否跳跃
	int iframe;		// 加载第几副眼睛图，这样就能让眼睛看上去动起来了
} eye;

struct GEAR		// 齿轮的结构体
{
	int x;
	int y;
	double iframe;  //齿轮动图控制
} gear[10];

double v0;				// 眼睛跳跃的初速度             
double Height;				// 眼睛跳跃的高度
double Time;				// 眼睛跳跃的时间
POINT pgear;                //储存齿轮在资料图中的坐标
IMAGE img_mapsky, img_p, img_map, img_ani, img_mapbk, img_home;

int win;				// 玩家是否过关
int pause;				// 玩家是否按Esc（暂停键）

/*void start()             //绘制初始界面——————————————————第二顺位的任务——————————————————//
{
	if (pause == 1)		// 如果按了暂停键
	{
		BeginBatchDraw();
		POINT points[4] = { { XSIZE / 2 - 45, YSIZE / 3 },{ XSIZE / 2 + 45, YSIZE / 3 },{ XSIZE / 2 + 45, YSIZE / 3 + 90 },{ XSIZE / 2 - 45, YSIZE / 3 + 90 } };
		setfillcolor(GREEN);
		fillpolygon(points, 4);
		setbkmode(TRANSPARENT);
		settextstyle(20, 0, "黑体");
		RECT r2 = { XSIZE / 2 - 45,YSIZE / 3,XSIZE / 2 + 45,YSIZE / 3 + 30 }; rectangle(XSIZE / 2 - 45, YSIZE / 3, XSIZE / 2 + 45, YSIZE / 3 + 30);
		drawtext("回到游戏", &r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
		RECT r3 = { XSIZE / 2 - 45,YSIZE / 3 + 30,XSIZE / 2 + 45,YSIZE / 3 + 60 }; rectangle(XSIZE / 2 - 45, YSIZE / 3 + 30, XSIZE / 2 + 45, YSIZE / 3 + 60);
		drawtext("重新开始", &r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
		RECT r4 = { XSIZE / 2 - 45,YSIZE / 3 + 60,XSIZE / 2 + 45,YSIZE / 3 + 90 }; rectangle(XSIZE / 2 - 45, YSIZE / 3 + 60, XSIZE / 2 + 45, YSIZE / 3 + 90);
		drawtext(" 主 菜 单 ", &r4, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
		FlushBatchDraw();

		MOUSEMSG m;
		while (true)
		{
			BeginBatchDraw();
			m = GetMouseMsg();
			switch (m.uMsg)
			{
			case WM_LBUTTONDOWN:
				EndBatchDraw();
				if (m.x>XSIZE / 2 - 45 && m.x<XSIZE / 2 + 45 && m.y>YSIZE / 3 && m.y<YSIZE / 3 + 30)
					return;
				else if (m.x>XSIZE / 2 - 45 && m.x<XSIZE / 2 + 45 && m.y>YSIZE / 3 + 30 && m.y<YSIZE / 3 + 60)
				{
					mciSendString("close all", NULL, 0, NULL);
					pause = 0;
					score = 0;
					return;
				}
				else if (m.x>XSIZE / 2 - 45 && m.x<XSIZE / 2 + 45 && m.y>YSIZE / 3 + 60 && m.y<YSIZE / 3 + 90)
				{
					mciSendString("close all", NULL, 0, NULL);
					pause = 0;
					score = 0;
					life = 0;
					cleardevice();
					break;
				}
				else
					break;
			case WM_MOUSEMOVE:
				RECT r;
				int i;
				for (i = 0; i<3; i++)
				{
					if (m.x>XSIZE / 2 - 45 && m.x<XSIZE / 2 + 45 && m.y>YSIZE / 3 + i * 30 && m.y<YSIZE / 3 + 30 + i * 30)
					{
						r.left = XSIZE / 2 - 45;
						r.top = YSIZE / 3 + i * 30;
						r.right = XSIZE / 2 + 45;
						r.bottom = YSIZE / 3 + 30 + i * 30;
						POINT points[4] = { { r.left,r.top },{ r.right,r.top },{ r.right,r.bottom },{ r.left,r.bottom } };
						setfillcolor(RED);
						fillpolygon(points, 4);
						setbkmode(TRANSPARENT);
						switch (i)
						{
						case 0:
							drawtext("回到游戏", &r, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
							break;
						case 1:
							drawtext("重新开始", &r, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
							break;
						case 2:
							drawtext(" 主 菜 单 ", &r, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
							break;
						}
					}
					else
					{
						if (getpixel(XSIZE / 2 - 45 + 1, YSIZE / 3 + i * 30 + 1) == RED)
						{
							r.left = XSIZE / 2 - 45;
							r.top = YSIZE / 3 + i * 30;
							r.right = XSIZE / 2 + 45;
							r.bottom = YSIZE / 3 + 30 + i * 30;
							POINT points[4] = { { r.left,r.top },{ r.right,r.top },{ r.right,r.bottom },{ r.left,r.bottom } };
							setfillcolor(GREEN);
							fillpolygon(points, 4);
							setbkmode(TRANSPARENT);
							switch (i)
							{
							case 0:
								drawtext("回到游戏", &r, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
								break;
							case 1:
								drawtext("重新开始", &r, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
								break;
							case 2:
								drawtext(" 主 菜 单 ", &r, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
								break;
							}
						}
						FlushBatchDraw();
					}
				}
			}
			if (pause == 0)
				break;
		}
	}
	if (life == 1 || life == 2)
		return;
	life = 3;
	score = 0;
	settextstyle(40, 0, "方正舒体");
	RECT r1 = { 0, 0, XSIZE, YSIZE / 3 };
	drawtext("超级蘑菇", &r1, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
	settextstyle(20, 0, "宋体");
	RECT r2 = { XSIZE / 2 - 45,YSIZE / 3,XSIZE / 2 + 45,YSIZE / 3 + 30 }; rectangle(XSIZE / 2 - 45, YSIZE / 3, XSIZE / 2 + 45, YSIZE / 3 + 30);
	drawtext("开始游戏", &r2, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
	RECT r3 = { XSIZE / 2 - 45,YSIZE / 3 + 30,XSIZE / 2 + 45,YSIZE / 3 + 60 }; rectangle(XSIZE / 2 - 45, YSIZE / 3 + 30, XSIZE / 2 + 45, YSIZE / 3 + 60);
	drawtext("游戏介绍", &r3, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
	RECT r4 = { XSIZE / 2 - 45,YSIZE / 3 + 60,XSIZE / 2 + 45,YSIZE / 3 + 90 }; rectangle(XSIZE / 2 - 45, YSIZE / 3 + 60, XSIZE / 2 + 45, YSIZE / 3 + 90);
	drawtext("操作说明", &r4, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
	RECT r5 = { XSIZE / 2 - 45,YSIZE / 3 + 90,XSIZE / 2 + 45,YSIZE / 3 + 120 }; rectangle(XSIZE / 2 - 45, YSIZE / 3 + 90, XSIZE / 2 + 45, YSIZE / 3 + 120);
	drawtext("退出游戏", &r5, DT_CENTER | DT_VCENTER | DT_SINGLELINE);

	int flag1 = 1, flag2 = 0, flag3 = 0;
	MOUSEMSG m;
	while (flag1 == 1)
	{
		BeginBatchDraw();
		m = GetMouseMsg();
		switch (m.uMsg)
		{
		case WM_LBUTTONDOWN:
			EndBatchDraw();
			if (m.x>XSIZE / 2 - 45 && m.x<XSIZE / 2 + 45 && m.y>YSIZE / 3 && m.y<YSIZE / 3 + 30 && flag1 == 1 && flag2 == 0 && flag3 == 0)
			{
				flag1 = 0;
				break;
			}
			else if (m.x>XSIZE / 2 - 45 && m.x<XSIZE / 2 + 45 && m.y>YSIZE / 3 + 30 && m.y<YSIZE / 3 + 60 && flag1 == 1 && flag3 == 0)
			{
				flag2 = 1;
				cleardevice();
				rectangle(50, 50, 213, 220);
				outtextxy(52, 52, "游戏介绍：");
				outtextxy(52, 82, "超级玛丽变");
				outtextxy(52, 102, "身超级蘑菇。");
				outtextxy(52, 132, "开发者：");
				outtextxy(52, 152, "木子念念");
				RECT R1 = { XSIZE - 46,YSIZE - 26,XSIZE - 2,YSIZE - 2 }; rectangle(XSIZE - 46, YSIZE - 26, XSIZE - 2, YSIZE - 2);
				drawtext("返回", &R1, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
				break;
			}
			else if (m.x>XSIZE / 2 - 45 && m.x<XSIZE / 2 + 45 && m.y>YSIZE / 3 + 60 && m.y<YSIZE / 3 + 90 && flag1 == 1 && flag2 == 0)
			{
				flag3 = 1;
				cleardevice();
				rectangle(50, 50, 213, 220);
				outtextxy(52, 52, "操作说明：");
				outtextxy(52, 72, "左移：A键");
				outtextxy(52, 92, "右移：D键");
				outtextxy(52, 112, "发射：J键");
				outtextxy(52, 132, "跳跃：W键/K键");
				outtextxy(52, 152, "暂停：Esc键");
				RECT R2 = { XSIZE - 46,YSIZE - 26,XSIZE - 2,YSIZE - 2 }; rectangle(XSIZE - 46, YSIZE - 26, XSIZE - 2, YSIZE - 2);
				drawtext("返回", &R2, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
				break;
			}
			else if (m.x>XSIZE / 2 - 45 && m.x<XSIZE / 2 + 45 && m.y>YSIZE / 3 + 90 && m.y<YSIZE / 3 + 120 && flag1 == 1 && flag2 == 0 && flag3 == 0)
				exit(0);
			else if (m.x>XSIZE - 46 && m.x<XSIZE - 3 && m.y>YSIZE - 26 && m.y<YSIZE - 3 && (flag2 == 1 || flag3 == 1))
			{
				cleardevice();
				flag1 = 0, flag2 = 0, flag3 = 0;
				start();
			}
			else
				break;
		case WM_MOUSEMOVE:
			RECT r;
			if (flag2 == 1 || flag3 == 1)
			{
				if (m.x>XSIZE - 46 && m.x<XSIZE - 3 && m.y>YSIZE - 26 && m.y<YSIZE - 3)
				{
					r.left = XSIZE - 46;
					r.top = YSIZE - 26;
					r.right = XSIZE - 2;
					r.bottom = YSIZE - 2;
					POINT points[4] = { { r.left,r.top },{ r.right,r.top },{ r.right,r.bottom },{ r.left,r.bottom } };
					setfillcolor(RED);
					fillpolygon(points, 4);
					setbkmode(TRANSPARENT);
					drawtext("返回", &r, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
				}
				else
				{
					if (getpixel(XSIZE - 46 + 1, YSIZE - 26 + 1) == RED)
					{
						r.left = XSIZE - 46;
						r.top = YSIZE - 26;
						r.right = XSIZE - 2;
						r.bottom = YSIZE - 2;
						POINT points[4] = { { r.left,r.top },{ r.right,r.top },{ r.right,r.bottom },{ r.left,r.bottom } };
						setfillcolor(BLACK);
						fillpolygon(points, 4);
						setbkmode(TRANSPARENT);
						drawtext("返回", &r, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
					}
				}
			}
			else
			{
				for (int i = 0; i<4; i++)
				{
					if (m.x>XSIZE / 2 - 45 && m.x<XSIZE / 2 + 45 && m.y>YSIZE / 3 + i * 30 && m.y<YSIZE / 3 + 30 + i * 30)
					{
						r.left = XSIZE / 2 - 45;
						r.top = YSIZE / 3 + i * 30;
						r.right = XSIZE / 2 + 45;
						r.bottom = YSIZE / 3 + 30 + i * 30;
						POINT points[4] = { { r.left,r.top },{ r.right,r.top },{ r.right,r.bottom },{ r.left,r.bottom } };
						setfillcolor(RED);
						fillpolygon(points, 4);
						setbkmode(TRANSPARENT);
						switch (i)
						{
						case 0:
							drawtext("开始游戏", &r, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
							break;
						case 1:
							drawtext("游戏介绍", &r, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
							break;
						case 2:
							drawtext("操作说明", &r, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
							break;
						case 3:
							drawtext("退出游戏", &r, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
							break;
						}
					}
					else
					{
						if (getpixel(XSIZE / 2 - 45 + 1, YSIZE / 3 + i * 30 + 1) == RED)
						{
							r.left = XSIZE / 2 - 45;
							r.top = YSIZE / 3 + i * 30;
							r.right = XSIZE / 2 + 45;
							r.bottom = YSIZE / 3 + 30 + i * 30;
							POINT points[4] = { { r.left,r.top },{ r.right,r.top },{ r.right,r.bottom },{ r.left,r.bottom } };
							setfillcolor(BLACK);
							fillpolygon(points, 4);
							setbkmode(TRANSPARENT);
							switch (i)
							{
							case 0:
								drawtext("开始游戏", &r, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
								break;
							case 1:
								drawtext("游戏介绍", &r, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
								break;
							case 2:
								drawtext("操作说明", &r, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
								break;
							case 3:
								drawtext("退出游戏", &r, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
								break;
							}
						}
					}
				}
			}
			FlushBatchDraw();
			break;
		default:
			break;
		}
	}
}*/

void init()                    //统一初始化各个变量、数组
{
	if (pause == 1)
		return;
	eye.id = 1;
	eye.x = X;
	eye.y = Y;
	eye.w = W;
	eye.h = H;
	eye.iframe = 1;
	eye.turn = 1;
	eye.jump = 0;

	v0 = 0;
	h = 0;
	t = 0;
	pgear.x = -1;
	pgear.y = -1;
	win = 0;
	pause = 0;
	int i;
	for (i = 0; i < 10; i++)
	{
		gear[i].x = -1;
		gear[i].y = -1;
		gear[i].iframe = 1;
	}
	loadimage(&img_mapsky, "res\\mapsky.jpg", XSIZE, YSIZE * 4);
	loadimage(&img_p, "res\\eye.gif");
	loadimage(&img_map, "res\\map.gif");
	loadimage(&img_ani, "res\\ani.gif");
	loadimage(&img_mapbk, "res\\mapbk.gif");
	loadimage(&img_home, "res\\home.jpg", XSIZE, YSIZE * 5);

	mciSendString("open res\\背景音乐.mp3 alias mymusic1", NULL, 0, NULL);
	mciSendString("open res\\子弹.mp3 alias mymusic2", NULL, 0, NULL);
	mciSendString("open res\\金币.mp3 alias mymusic3", NULL, 0, NULL);
	mciSendString("open res\\跳.mp3 alias mymusic4", NULL, 0, NULL);
	mciSendString("open res\\子弹打到敌人.mp3 alias mymusic5", NULL, 0, NULL);
	mciSendString("open res\\子弹撞墙.mp3 alias mymusic6", NULL, 0, NULL);
	mciSendString("open res\\踩敌人.mp3 alias mymusic7", NULL, 0, NULL);
	mciSendString("open res\\吃到武器.mp3 alias mymusic8", NULL, 0, NULL);
	mciSendString("open res\\胜利.mp3 alias mymusic9", NULL, 0, NULL);
	mciSendString("open res\\死亡1.mp3 alias mymusic10", NULL, 0, NULL);
	mciSendString("open res\\死亡2.mp3 alias mymusic11", NULL, 0, NULL);
}

int GetCommand()
{
	int c = 0;

	if (GetAsyncKeyState('A') & 0x8000)
		c |= CMD_LEFT;
	if (GetAsyncKeyState('D') & 0x8000)
		c |= CMD_RIGHT;
	if ((GetAsyncKeyState('W') & 0x8000) || (GetAsyncKeyState('K') & 0x8000))
		c |= CMD_UP;
	if (GetAsyncKeyState('S') & 0x8000)
		c |= CMD_DOWN;
	if (GetAsyncKeyState('J') & 0x8000)
		c |= CMD_SHOOT;
	if (GetAsyncKeyState(VK_ESCAPE) & 0x8000)
		c |= CMD_ESC;
	return c;
}
void main()
{
	initgraph(640, 480);
}
